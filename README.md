# cpp-clang-example

Minimal C++ project with one intentional resource leak and a custom clang-tidy plugin that flags `fopen` without a matching `fclose` in the same function. A script converts clang-tidy output to SARIF.

## Prereqs (macOS/Homebrew suggested)
- CMake 3.16+
- LLVM/Clang with clang-tidy (e.g., `brew install llvm`)

## Build
```bash
./scripts/build.sh
```

## Run clang-tidy with the plugin and generate SARIF
```bash
./scripts/run_tidy.sh
```
Outputs:
- `out/tidy.txt`: raw clang-tidy text output
- `out/tidy.sarif`: SARIF v2.1.0

## What’s in this repo
- `src/main.cpp`: tiny program with an intentional leak: `fopen` without `fclose`.
- `tidy-plugin/`:
  - `CallPairCheck.h/.cpp`: a custom clang-tidy check that finds functions that call `fopen` but not `fclose`.
  - `TidyModule.cpp`: registers the check with clang-tidy under the name `example-call-pair-check`.
  - `CMakeLists.txt`: builds the plugin as a shared module (`TidyLeakCheck.so`/`.dylib`).
- `scripts/`:
  - `build.sh`: configures and builds the app and the plugin; auto-detects Homebrew LLVM if present.
  - `run_tidy.sh`: runs clang-tidy, loads the plugin, executes our check, and converts output to SARIF.
  - `tidy_to_sarif.py`: transforms clang-tidy text diagnostics to SARIF 2.1.0.
- `.clang-tidy`: enables only our check (`example-call-pair-check`).

## How the custom clang-tidy validator works
### Architecture in one minute
- **clang-tidy plugin (our code)**: A shared library that defines a `ClangTidyModule` and one or more `ClangTidyCheck`s.
- **Module registration** (`tidy-plugin/TidyModule.cpp`):
  - Implements a subclass of `ClangTidyModule` and registers check factories by name.
  - Example: registers `example-call-pair-check` → this name is how clang-tidy discovers and runs our check.
- **The check** (`tidy-plugin/CallPairCheck.*`):
  - Subclasses `clang::tidy::ClangTidyCheck`.
  - `registerMatchers(...)`: uses Clang AST Matchers to find function definitions that contain a call to `::fopen(...)` but no call to `::fclose(...)` anywhere in the same function body.
  - `check(...)`: runs when a match is found; emits a diagnostic via `diag(...)` at the `fopen` callsite.

### What happens when you run the script
- `scripts/run_tidy.sh` does three things:
  - Finds the built plugin (`TidyLeakCheck.so`/`.dylib`) and a suitable `clang-tidy` binary.
  - Invokes `clang-tidy` with:
    - `-p build/` so it reads `compile_commands.json` (exact compile flags for your files),
    - `-load <plugin>` to load our module,
    - `-checks=-*,example-call-pair-check` to run only our custom check,
    - additional macOS SDK flags so standard headers are found.
  - Pipes the output to `scripts/tidy_to_sarif.py`, which produces `out/tidy.sarif`.

### How the matcher works (high-level)
- The matcher looks for:
  - A function definition (`functionDecl(isDefinition(), ...)`)
  - That has a descendant `callExpr` to `::fopen` (bound as `"call"`)
  - And does not have any descendant call to `::fclose` in the same function body
- On each match, `check(...)` emits the warning:
  - "function 'X' calls fopen but does not call fclose; potential resource leak"

### Why the `-p build` and `compile_commands.json` matter
- clang-tidy compiles your code under the hood to get a precise AST.
- `compile_commands.json` (generated by CMake) tells clang-tidy which flags/defines/includes to use so analysis is accurate.

### Extending: write your own validators
- Add a new `*.h/*.cpp` pair implementing another `ClangTidyCheck`.
- Register it in `TidyModule.cpp` with a unique name.
- Rebuild and run with `-checks=-*,your-check-name` (or add it to `.clang-tidy`).
- You can pattern-match almost anything via AST Matchers (see LLVM’s matcher reference) and then signal a problem with `diag(...)`.

### Limitations of this simple example
- The `fopen`/`fclose` pairing is checked only within a single function body; it doesn’t track ownership across functions or error paths.
- It may report false positives for functions that purposely transfer ownership.

## Cleaning up / housekeeping
- Build products go to `build/` and analysis outputs to `out/` (both ignored by git).
- It’s safe to delete `build/` and `out/` at any time. 